<!DOCTYPE html>
<html>
  <head>    

<script src="https://rawgit.com/chenzlabs/aframe/tracked-controls-fix-dist/dist/aframe-master.js"></script>
        
  </head>
<body>
  
<script>
  AFRAME.registerComponent('sync-position-yaw', {
    schema: {type: 'selector'},
    tick: function (t, dt) {
      var pos = this.data.object3D.position; //getAttribute('position');
      this.el.setAttribute('position', pos);
      this.el.setAttribute('rotation', 'y', this.data.getAttribute('rotation').y);
    }
  });
</script>

<script>
  AFRAME.registerComponent('sync-pose', {
    schema: {
      src: {type: 'selector'},
      offset: {type: 'vec3'}
    },
    
    init: function () {
      this.tempPos = new THREE.Vector3();
    },
    
    tick: function (t, dt) {
      this.tempPos.copy(this.data.offset);
      this.tempPos.applyQuaternion(this.data.src.object3D.quaternion);
      this.tempPos.add(this.data.src.object3D.position);
      this.el.setAttribute('position', this.tempPos);
      this.el.setAttribute('rotation', this.data.src.getAttribute('rotation'));
    }
  });
</script>  

<script>
  AFRAME.registerComponent('compute-elbow', {
    schema: {
      length: {default: 0.3},
      gravity: {type: 'vec3', default: '0 -1 0'},
      shoulder: {type: 'selector'},
      wrist: {type: 'selector'},
      origin: {type: 'selector'}
    },
    
    init: function () {
      this.tempPos = new THREE.Vector3();
      this.tempPos2 = new THREE.Vector3();
      this.tempPos3 = new THREE.Vector3();
    },
    
    tick: function (t, dt) {
      // compute halfway between shoulder and wrist
      this.tempPos.copy(this.data.wrist.object3D.position);
      this.tempPos.sub(this.data.shoulder.object3D.position);
      this.tempPos.divideScalar(2);
      
      // if not long enough (which seems rather likely), pull it
      var d2 = this.tempPos.lengthSq();
      if (d2 < this.data.length * this.data.length) {
        var d = Math.sqrt(this.data.length * this.data.length - d2);
        
        // ... in the direction of origin to shoulder, plus gravity (?)
        this.tempPos2.copy(this.data.shoulder.object3D.position);
        this.tempPos2.sub(this.data.origin.object3D.position);
        this.tempPos2.add(this.data.gravity);
        this.tempPos2.normalize();
        // FIXME: this is wrong assuming the vector is NOT perpendicular...
        //this.tempPos2.multiplyScalar(d);
        
        // Compute the unit vector that is perpendicular to this.tempPos and coplanar with this.tempPos2 ...
        // if dot product is zero, we're already perpendicular.  
        // Otherwise, we need to figure out what ratio to add to make it zero.
        // Compute the angle between the two vectors.
        this.tempPos3.copy(this.tempPos);
        this.tempPos3.normalize();
        var costheta = this.tempPos2.dot(this.tempPos3);
        // Make a perpendicular vector, although it will not be a unit vector.        
        this.tempPos3.multiplyScalar(costheta);
        this.tempPos2.sub(this.tempPos3);
        
        this.tempPos2.normalize();
        this.tempPos2.multiplyScalar(d);
        
        this.tempPos.add(this.tempPos2); 
      }      
      
      this.tempPos.add(this.data.shoulder.object3D.position);
      this.el.setAttribute('position', this.tempPos);
      //this.el.setAttribute('rotation', this.data.origin.getAttribute('rotation'));
    }
  });
</script>    

<script>
  AFRAME.registerComponent('show-parent-to-target', {
    schema: {
      target: {type: 'selector'},
      radius: {default: 0.01}
    },
    
    init: function () {
      this.from = new THREE.Vector3(0, 1, 0);
      this.tempPos = new THREE.Vector3();
      this.tempQuat = new THREE.Quaternion();      
    },
    
    update: function (oldData) {
      this.el.setAttribute('geometry', 'radius', this.data.radius);
    },
    
    tick: function (t, dt) {
      this.tempPos.copy(this.data.target.object3D.position);
      this.tempPos.sub(this.el.parentElement.object3D.position);

      // compute height (length but we're using a cylinder)
      this.el.setAttribute('geometry', 'height', this.tempPos.length());
      
      // compute halfway between
      this.tempPos.divideScalar(2);
      this.el.setAttribute('position', this.tempPos);
      
      // compute orientation
      // FIXME: compute relative rotation!
      this.tempPos.normalize();
      this.tempQuat.setFromUnitVectors(this.from, this.tempPos);
      this.el.object3D.quaternion.copy(this.tempQuat);
    }
  });
</script>    
    
<a-scene background="color:#3cf">
  <a-entity id="player" wasd-controls>
    <!-- new master bug: when entering VR, HMD Y position is negative, wtf? -->
    
    <a-entity id="hmd" camera="active:false">
      <a-text id="hud" value="Hi there!" align="center" wrap-count="1000" position="0 -0.1 -0.25"></a-text>
      
<!--
Forward is negative Z; make attachment point 
From HMD position, neck is about 0, -0.2, 0.1
-->
      <a-sphere id="hmd-ball" radius="0.01">
        <a-sphere id="hmd-to-headcenter" position="0 -0.04 0.09" radius="0.01">
          <a-sphere opacity="0.5" scale="0.08 0.12 0.09">
          </a-sphere>
        </a-sphere>
      </a-sphere>
      
      <a-sphere id="hmd-to-neck" position="0 -0.16 0.12" radius="0.01">
          <a-sphere id="neck-to-left-shoulder" position="-0.2 0 0" radius="0.01">
          </a-sphere>
          <a-sphere id="neck-to-right-shoulder" position="0.2 0 0" radius="0.01">
          </a-sphere>
      </a-sphere>
<!--      
      <a-sphere opacity="0.5" scale="0.1 0.125 0.075">
        <a-cone opacity="0.5" color="magenta" position="0 -0.25 -1.05" scale="0.03 0.3 0.04" rotation="-90 0 0"></a-cone>
      </a-sphere> 
-->
    </a-entity>
    <a-entity id="left-hand" laser-controls="hand:left">
<!--      
        <a-sphere id="lh-ball" radius="0.01">
          <a-sphere id="lh-to-handcenter" position="0 0 0.05" radius="0.01">
          </a-sphere>
          <a-sphere id="lh-to-wrist" position="0 0 0.12" radius="0.01">
          </a-sphere>
        </a-sphere>
-->
      <a-sphere opacity="0.5" scale="0.025 0.02 0.1">
        <a-cone opacity="0.5" color="red" position="0 -0.25 -1" scale="0.5 2 0.5" rotation="-90 0 0"></a-cone>
      </a-sphere>
    </a-entity>
    <a-sphere id="left-wrist" radius="0.015" color="red" sync-pose="src:#left-hand; offset:0 -0.04 0.12"></a-sphere>
    <a-sphere id="left-shoulder" radius="0.015" color="red" sync-pose="src:#hmd; offset:-0.2 -0.2 0.03"></a-sphere>
    <a-sphere id="left-elbow" radius="0.015" color="red" compute-elbow="shoulder:#left-shoulder; wrist:#left-wrist; origin:#hmd">
      <a-cylinder show-parent-to-target="target:#left-shoulder"></a-cylinder>
      <a-cylinder show-parent-to-target="target:#left-wrist"></a-cylinder>
    </a-sphere>
    
    <a-entity id="right-hand" laser-controls="hand:right">
<!--      
        <a-sphere id="rh-ball" radius="0.01">
          <a-sphere id="rh-to-handcenter" position="0 0 0.05" radius="0.01">
          </a-sphere>
          <a-sphere id="rh-to-wrist" position="0 0 0.12" radius="0.01">
          </a-sphere>
        </a-sphere>
-->
      <a-sphere opacity="0.5" scale="0.025 0.02 0.1">
        <a-cone opacity="0.5" color="blue" position="0 -0.25 -1" scale="0.5 2 0.5" rotation="-90 0 0"></a-cone>
      </a-sphere>
    </a-entity>
    <a-sphere id="right-wrist" radius="0.015" color="blue" sync-pose="src:#right-hand; offset:0 -0.04 0.12"></a-sphere>\
    <a-sphere id="right-shoulder" radius="0.015" color="blue" sync-pose="src:#hmd; offset:0.2 -0.2 0.03"></a-sphere>
    <a-sphere id="right-elbow" radius="0.015" color="blue" compute-elbow="shoulder:#right-shoulder; wrist:#right-wrist; origin:#hmd">
      <a-cylinder show-parent-to-target="target:#right-shoulder"></a-cylinder>
      <a-cylinder show-parent-to-target="target:#right-wrist"></a-cylinder>
    </a-sphere>
    
    <a-entity id="model" rotation="0 180 0" not-gltf-model="https://ucarecdn.com/d9c8bc96-46e9-4b43-9987-c393720049cf/"></a-entity>
  </a-entity>

  <a-entity id="buddy" position="0 0 -2" not-gltf-model="https://ucarecdn.com/d9c8bc96-46e9-4b43-9987-c393720049cf/"></a-entity>
</a-scene>

<script>
/*
var model=document.querySelector('a-gltf-model').components['gltf-model'];
var root=model.model.children[0].children[0];
// root.position.x=1 is "right" (model's left)
// root.position.z=1 is up
// root.position.y=1 is forward
*/
</script>

<script>
  window.addEventListener('wheel', function (evt) {
    var moveme = "#left-hand"; //foot"; //"#left-hand";
    if (!document.querySelector('a-scene').isPlaying) { return; }
    var dz = evt.wheelDeltaY / 100;
    var dx = evt.wheelDeltaX / 100;
    var p = document.querySelector(moveme).getAttribute('position');
    document.querySelector(moveme).setAttribute('position', {x: p.x + dx, z: p.z + dz});
  });
  function vrPosition() {
    console.log("vrPosition()");
    var sceneEl = document.querySelector('a-scene');
    // switch camera and look-controls to head so you don't get sick wearing the HMD
    sceneEl.querySelector('#hmd').setAttribute('camera', 'active', true);    
    sceneEl.querySelector('#hmd').setAttribute('look-controls', '');    
  }
  function nonVRPosition() {
    console.log("nonVRPosition()");
    // reset position for head and hands, since they will be taken over by HMD and controllers
    // TODO: have controllers and trackers handle that themselves
    var sceneEl = document.querySelector('a-scene');
    Array.prototype.slice.call(sceneEl.querySelectorAll('[non-vr-position]')).forEach(function (el) {
      console.log(el);
      var attr = el.getAttribute('non-vr-position');
      console.log(attr);
      el.setAttribute('position', attr);
    });
  }

    // FIX ONE: point raycaster in the right direction
    AFRAME.components['laser-controls'].Component.prototype.config['oculus-touch-controls'].raycaster.direction.y = 0;

    AFRAME.components['oculus-touch-controls'].originalOnModelLoaded = AFRAME.components['oculus-touch-controls'].Component.prototype.onModelLoaded;
    AFRAME.components['oculus-touch-controls'].Component.prototype.onModelLoaded = function (evt) {
      AFRAME.components['oculus-touch-controls'].originalOnModelLoaded.call(this, evt);        
      // FIX TWO: align model with raycaster (and reality)
      this.el.object3D.traverse(function (child) {
        if (child instanceof THREE.Mesh) {
          if (child.name.indexOf("body_oculus-touch-controller-") == 0) {
            child.parent.rotateX(Math.PI / 4);
            child.parent.translateY(0.06);
          }
        }
      });
    };
    
  
  function onSceneLoaded() {
    console.log("onSceneLoaded()");
    
    // undesirable hack to fix Oculus Touch pose, from https://github.com/aframevr/aframe/issues/2965#issuecomment-341949659
    // which doesn't work for me

    if (!navigator.getVRDisplays) {
      console.log("!navigator.getVRDisplays");
      nonVRPosition();
          //document.querySelector("[structure]").components.structure.needUpdate();
    } else {
      navigator.getVRDisplays().then(function (displays) {
        if (displays && displays.length > 0) { 
          console.log("navigator.getVRDisplays() then displays[0]");
          // nonVRPosition(); //
          vrPosition(); 
        } else {
          console.log("navigator.getVRDisplays() then no displays[0]");
          nonVRPosition();
          //document.querySelector("[structure]").components.structure.needUpdate();
        }
      }).catch(function (err) {
        console.log("navigator.getVRDisplays() catch");
        nonVRPosition(); 
          //document.querySelector("[structure]").components.structure.needUpdate();
      });
    }
    
    var hud = document.querySelector('#hud');
    var hmd = document.querySelector('#hmd');
    var lh = document.querySelector('#left-hand');
    var rh = document.querySelector('#right-hand');
    var lw = document.querySelector('#left-wrist');
    var rw = document.querySelector('#right-wrist');
    var ls = document.querySelector('#left-shoulder');
    var rs = document.querySelector('#right-shoulder');
    var le = document.querySelector('#left-elbow');
    var re = document.querySelector('#right-elbow');
    setInterval(function () {
      hud.setAttribute('value',
        'Y values:'
        + '\nhmd = (' + hmd.getAttribute('position').x.toFixed(3)
          + ', ' + hmd.getAttribute('position').y.toFixed(3)
          + ', ' + hmd.getAttribute('position').z.toFixed(3) + ')'
        + '\nleft-hand = (' + lh.getAttribute('position').x.toFixed(3)
          + ', ' + lh.getAttribute('position').y.toFixed(3)
          + ', ' + lh.getAttribute('position').z.toFixed(3) + ')'
        + '\nright-hand = (' + rh.getAttribute('position').x.toFixed(3)
          + ', ' + rh.getAttribute('position').y.toFixed(3)
          + ', ' + rh.getAttribute('position').z.toFixed(3) + ')'
        + '\nleft-wrist = (' + lw.getAttribute('position').x.toFixed(3)
          + ', ' + lw.getAttribute('position').y.toFixed(3)
          + ', ' + lw.getAttribute('position').z.toFixed(3) + ')'
        + '\nright-wrist = (' + rw.getAttribute('position').x.toFixed(3)
          + ', ' + rw.getAttribute('position').y.toFixed(3)
          + ', ' + rw.getAttribute('position').z.toFixed(3) + ')'
        + '\nleft-shoulder = (' + ls.getAttribute('position').x.toFixed(3)
          + ', ' + ls.getAttribute('position').y.toFixed(3)
          + ', ' + ls.getAttribute('position').z.toFixed(3) + ')'
        + '\nright-shoulder = (' + rs.getAttribute('position').x.toFixed(3)
          + ', ' + rs.getAttribute('position').y.toFixed(3)
          + ', ' + rs.getAttribute('position').z.toFixed(3) + ')'
        + '\nleft-elbow = (' + le.getAttribute('position').x.toFixed(3)
          + ', ' + le.getAttribute('position').y.toFixed(3)
          + ', ' + le.getAttribute('position').z.toFixed(3) + ')'
        + '\nright-wrist = (' + re.getAttribute('position').x.toFixed(3)
          + ', ' + re.getAttribute('position').y.toFixed(3)
          + ', ' + re.getAttribute('position').z.toFixed(3) + ')'
      );
    }, 1000);
  }
  
  var sceneEl = document.querySelector('a-scene');
  if (sceneEl.hasLoaded) {
    onSceneLoaded();
  } else {
    sceneEl.addEventListener('loaded', onSceneLoaded);
  }
</script>
  </body>
</html>
